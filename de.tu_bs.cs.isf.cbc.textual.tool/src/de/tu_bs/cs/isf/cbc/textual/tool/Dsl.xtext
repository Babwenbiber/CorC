grammar de.tu_bs.cs.isf.cbc.textual.tool.Dsl with  jbase.Jbase // org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.example.org/cbcmodel"
//import "http://www.eclipse.org/xtext/xbase/Xbase"
//import "http://www.eclipse.org/xtext/common/JavaVMTypes"
CbCProblem returns CbCProblem:
		(cbcformula=CbCFormula 
		& (globalcondition=GlobalConditions)? 
		& (javaVariable=JavaVariables)? 
		& (renaming=Renaming)?)
		| BlockStatement
		;

CbCFormula returns CbCFormula:
	'Formula'
	name=EString
		'Pre:' '(' preCondition=Condition ')'
		'{' statement=AbstractStatement '}'
		'Post:' '(' postCondition=Condition ')'
	;

AbstractStatement returns AbstractStatement:
	AbstractStatement_Impl | InlineBlockStatement | CompositionStatement | SkipStatement | SelectionStatement | SmallRepetitionStatement | MethodStatement | ReturnStatement | StrengthWeakStatement;


EString returns ecore::EString:
	STRING | ID;
	
	
CodeString returns ecore::EString: 
			(VariableString '=' "("? VariableString (Operation VariableString)* ")"? ';')+
		;

//CodeString returns ecore::EString: 
//			(ID ('[' (ID | INT) ']')? '=' TermString ';')+
//		;		
//		
//TermString returns ecore::EString:
//	'('? (VariableString | '-'? INT | TermString2) Operation TermString ')'?
//;
//
//TermString2 returns ecore::EString:
//	'('? (VariableString | '-'? INT | TermString) Operation TermString ')'?
//;
		
VariableString returns ecore::EString:
	'-'? (INT | QualifiedName ( 
			('(' ( '-'?(QualifiedName |  INT) (',' '-'?(QualifiedName |  INT))*)? ')') |
			('[' '-'?(QualifiedName |  INT) (Operation '-'?(QualifiedName | INT))* ']')
		)?)
;
		//ID( ('[' | '(') ( (VariableString | INT) (',' (VariableString | INT))*)? (']' | ')'))?
Operation:
	'+' | '-' | '*' | '/' | '%';	

AbstractStatement_Impl returns AbstractStatement:
	{AbstractStatement}
		name=CodeString;
		
MethodStatement returns AbstractStatement:
	{MethodStatement}
		name=EString;
		
ReturnStatement returns AbstractStatement:
	{ReturnStatement}
		'Return' name=CodeString;
		
StrengthWeakStatement returns AbstractStatement:
	{StrengthWeakStatement}
	'Pre:' '(' weakPreCondition=Condition ')'
		'{' name=CodeString '}'
		'Post:' '(' strongPostCondition=Condition ')'
;
		

Condition:
	{Condition} condition=Expression;

SkipStatement returns AbstractStatement:
		 name=';'
	;

CompositionStatement returns AbstractStatement:
	{CompositionStatement}
		'{' firstStatement=AbstractStatement '}'
		'Intm:' '(' intermediateCondition=Condition ')'
		'{' secondStatement=AbstractStatement '}'
	;

JavaStatement returns AbstractStatement:
	{JavaStatement}
	(statement+=XJStatementOrBlock)+
;

JMLAnnotation returns JMLAnnotation:
	"Pre:" "(" requires=Condition ")" &
	"Post:" "(" ensures=Condition  ")"
;

InlineBlockStatement returns AbstractStatement:
	{InlineBlockStatement}
	block=BlockStatement | {InlineBlockStatement} "Block" references=[BlockStatement] ";"
;

BlockStatement returns AbstractStatement:
{BlockStatement}
		'Block' name=EString ':'
			(jmlAnnotation=JMLAnnotation)?
			blockJavaMix=BlockJavaMix			 
	;

BlockJavaMix returns AbstractStatement:
{BlockJavaMix}
	'{'
		(=>javaBlockStatement=JavaBlockStatement |
		blockJavaStatement=BlockJavaStatement)
	'}'
;

JavaBlockStatement returns AbstractStatement:
{JavaBlockStatement}
	(=>((leading=JavaStatement) (body+=BlockJavaTuple)*) | (body+=JavaBlockTuple)*)
;

BlockJavaStatement returns AbstractStatement:
{BlockJavaStatement}
	(=>((leading=BlockStatement) (body+=JavaBlockTuple)*) | (body+=BlockJavaTuple)*)
;


BlockJavaTuple returns AbstractStatement:
{BlockJavaTuple}
	(blockStatement=InlineBlockStatement javaStatement=JavaStatement)
;

JavaBlockTuple returns AbstractStatement:
{JavaBlockTuple}
	(javaStatement=JavaStatement  blockStatement=InlineBlockStatement)
;

SelectionStatement returns AbstractStatement:
	{SelectionStatement}
		'If' '(' guards+=Condition ')' 'Then' '{' commands+=AbstractStatement '}'
		('Elseif' '(' guards+=Condition ')' 'Then' '{' commands+=AbstractStatement '}')* 'Fi'
	;

SmallRepetitionStatement returns AbstractStatement:
	{SmallRepetitionStatement}
		'While' '(' guard=Condition ')' 'Do'
		'Inv:' '(' invariant=Condition ')'
		'Var:' '(' variant=Variant ')'
		'{' loopStatement=AbstractStatement '}' 'Od'
	;

EInt returns ecore::EInt:
	'-'? INT;

Variant returns Variant:
	{Variant}
	var=MultiMathOperation;

JavaVariables returns JavaVariables:
	{JavaVariables}
	'JavaVariables'
	('Variables' '[' variables+=JavaVariable ( "," variables+=JavaVariable)* ']')?;

JavaVariable returns JavaVariable:
	{JavaVariable}
	type=JvmTypeReference var=VariableOrMethodName;
	
GlobalConditions returns GlobalConditions:
	{GlobalConditions}
	'GlobalConditions'
	('Conditions' '[' conditions+=Condition ( "," conditions+=Condition)* ']')?;
	
Renaming returns Renaming:
	{Renaming}
	'Renaming'
	('Renames' '[' rename+=Rename (rename+=Rename)* ']')?;

Rename returns Rename:
	{Rename}
	'{'
	'Type' type=EString
	'Function' function=EString
	'NewName' newName=EString
	'}'
	;

Expression:
	Implication;
	
VariableOrMethodName:
	name=ID;
	
Implication returns Expression:
	Concat (( {Impl.left=current} '->') right=Concat)*;

Concat returns Expression:
	Foreach (({And.left=current} '&' | {Or.left=current} '|') right=Foreach)*;
	
Foreach returns Expression:
	Exists | (foreach="(\\forall" type=JvmTypeReference var=VariableOrMethodName ";" right=Exists ")")
;

Exists returns Expression:
	Relation | (exists="(\\exists" type=JvmTypeReference var=VariableOrMethodName ";" right=Relation ")")
;

Relation returns Expression:
	MultiMathOperation( ({Lower.left=current} "<" | {Greater.left=current} ">" | {Equal.left=current} "=" | {NotEqual.left=current} "!=" |{LowerEqual.left=current} "<=" | {GreaterEqual.left=current} ">=") right=MultiMathOperation)*;
	
MultiMathOperation returns Expression:
	AddMathOperation (( {Multiplication.left=current} '*' | {Division.left=current} "/" | {Modulo.left=current} "%") right=AddMathOperation)*;

AddMathOperation returns Expression:
	QualifiedExpression (({Addition.left=current} '+' | {Subtraction.left=current} '-') right=QualifiedExpression)*;	

QualifiedExpression returns Expression:
	PrimaryExpression (=>({Qualifier.left=current} ".") right=PrimaryExpression)*;

PrimaryExpression returns Expression:
    {Expression} => ('false' | isTrue?='true') |
	'!' ? '(' Expression ')' |
	{FunctionCall} '!' ? func=VariableOrMethodName ('(' (args+=Expression (',' args+=Expression)* )?')')? |
	{ArrayElement} '!' ? array=VariableOrMethodName ('[' (element+=Expression ']'('[' element+=Expression ']')* )?) |	
	{Expression} INT |
	{Expression} STRING |
	{Expression} CHARACTER |
	{Expression} "null"
	 ;