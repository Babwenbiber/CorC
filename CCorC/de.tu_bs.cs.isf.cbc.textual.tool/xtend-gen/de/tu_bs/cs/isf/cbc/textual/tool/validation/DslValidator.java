/**
 * generated by Xtext 2.10.0
 */
package de.tu_bs.cs.isf.cbc.textual.tool.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import de.tu_bs.cs.isf.cbc.cbcmodel.AbstractStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.CbCFormula;
import de.tu_bs.cs.isf.cbc.cbcmodel.CbcmodelPackage;
import de.tu_bs.cs.isf.cbc.cbcmodel.Condition;
import de.tu_bs.cs.isf.cbc.cbcmodel.Confidentiality;
import de.tu_bs.cs.isf.cbc.cbcmodel.JavaVariable;
import de.tu_bs.cs.isf.cbc.cbcmodel.MethodStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.ReturnStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.SelectionStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.SkipStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.SmallRepetitionStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.StrengthWeakStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.impl.AbstractStatementImpl;
import de.tu_bs.cs.isf.cbc.cbcmodel.impl.ReturnStatementImpl;
import de.tu_bs.cs.isf.cbc.textual.tool.validation.AbstractDslValidator;
import de.tu_bs.cs.isf.cbc.textual.tool.validation.TraverseFormula;
import de.tu_bs.cs.isf.cbc.util.ProveWithKey;
import de.tu_bs.cs.isf.toolkit.support.compare.CompareMethodBodies;
import java.util.Iterator;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DslValidator extends AbstractDslValidator {
  public final static String INVALID_NAME = "invalidName";
  
  public final static String NOT_PROVED = "notProved";
  
  @Check
  public void checkSyntaxOfStatement(final AbstractStatement statement) {
    Class<? extends AbstractStatement> _class = statement.getClass();
    boolean _equals = _class.equals(AbstractStatementImpl.class);
    if (_equals) {
      if (((!Objects.equal(statement.getName(), null)) && (!statement.getName().isEmpty()))) {
        String _name = statement.getName();
        boolean _readAndTestMethodBodyWithJaMoPP2 = CompareMethodBodies.readAndTestMethodBodyWithJaMoPP2(_name);
        boolean _not = (!_readAndTestMethodBodyWithJaMoPP2);
        if (_not) {
          this.warning("Statement has not the correct syntax.", 
            CbcmodelPackage.Literals.ABSTRACT_STATEMENT__NAME, 
            DslValidator.INVALID_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkSyntaxOfReturnStatement(final ReturnStatement statement) {
    Class<? extends ReturnStatement> _class = statement.getClass();
    boolean _equals = _class.equals(ReturnStatementImpl.class);
    if (_equals) {
      if (((!Objects.equal(statement.getName(), null)) && (!statement.getName().isEmpty()))) {
        String _name = statement.getName();
        boolean _readAndTestMethodBodyWithJaMoPP2 = CompareMethodBodies.readAndTestMethodBodyWithJaMoPP2(_name);
        boolean _not = (!_readAndTestMethodBodyWithJaMoPP2);
        if (_not) {
          this.warning("Statement has not the correct syntax.", 
            CbcmodelPackage.Literals.ABSTRACT_STATEMENT__NAME, 
            DslValidator.INVALID_NAME);
        }
      }
    }
  }
  
  @Check
  public void checkSyntaxOfCondition(final Condition condition) {
    if (((((!Objects.equal(condition.getName(), null)) && (!condition.getName().isEmpty())) && (!condition.getName().contains("forall"))) && (!condition.getName().contains("exists")))) {
      String _nameSplit = condition.getNameSplit();
      String _replaceAll = _nameSplit.replaceAll("->", "&");
      boolean _readAndTestAssertWithJaMoPP = CompareMethodBodies.readAndTestAssertWithJaMoPP(_replaceAll);
      boolean _not = (!_readAndTestAssertWithJaMoPP);
      if (_not) {
        this.warning("Condition has not the correct syntax.", 
          CbcmodelPackage.Literals.CONDITION__NAME, 
          DslValidator.INVALID_NAME);
      }
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void checkProveOfStatement(final AbstractStatement statement) {
    Class<? extends AbstractStatement> _class = statement.getClass();
    boolean _equals = _class.equals(AbstractStatementImpl.class);
    if (_equals) {
      Resource _eResource = statement.eResource();
      TreeIterator<EObject> _allContents = _eResource.getAllContents();
      Iterator<CbCFormula> _filter = Iterators.<CbCFormula>filter(_allContents, CbCFormula.class);
      CbCFormula formula = _filter.next();
      TraverseFormula traverser = new TraverseFormula();
      traverser.traverseFormula(formula, statement);
      int numberFile = traverser.foundFile;
      Resource _eResource_1 = statement.eResource();
      URI _uRI = _eResource_1.getURI();
      final boolean closed = ProveWithKey.checkFileIsProved(_uRI, numberFile);
      if ((!closed)) {
        this.info("Statement is not proved.", 
          CbcmodelPackage.Literals.ABSTRACT_STATEMENT__PROVEN, 
          DslValidator.NOT_PROVED);
      }
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void checkProveOfReturnStatement(final ReturnStatement statement) {
    Resource _eResource = statement.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    Iterator<CbCFormula> _filter = Iterators.<CbCFormula>filter(_allContents, CbCFormula.class);
    CbCFormula formula = _filter.next();
    TraverseFormula traverser = new TraverseFormula();
    traverser.traverseFormula(formula, statement);
    int numberFile = traverser.foundFile;
    Resource _eResource_1 = statement.eResource();
    URI _uRI = _eResource_1.getURI();
    final boolean closed = ProveWithKey.checkFileIsProved(_uRI, numberFile);
    if ((!closed)) {
      this.info("ReturnStatement is not proved.", 
        CbcmodelPackage.Literals.ABSTRACT_STATEMENT__PROVEN, 
        DslValidator.NOT_PROVED);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void checkProveOfStrengthWeakStatement(final StrengthWeakStatement statement) {
    Resource _eResource = statement.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    Iterator<CbCFormula> _filter = Iterators.<CbCFormula>filter(_allContents, CbCFormula.class);
    CbCFormula formula = _filter.next();
    TraverseFormula traverser = new TraverseFormula();
    traverser.traverseFormula(formula, statement);
    int numberFile = traverser.foundFile;
    Resource _eResource_1 = statement.eResource();
    URI _uRI = _eResource_1.getURI();
    final boolean closedPre = ProveWithKey.checkFileIsProved(_uRI, numberFile);
    Resource _eResource_2 = statement.eResource();
    URI _uRI_1 = _eResource_2.getURI();
    final boolean closedPost = ProveWithKey.checkFileIsProved(_uRI_1, (numberFile + 1));
    Resource _eResource_3 = statement.eResource();
    URI _uRI_2 = _eResource_3.getURI();
    final boolean closedStd = ProveWithKey.checkFileIsProved(_uRI_2, (numberFile + 2));
    if ((!closedPre)) {
      this.info("PreCondition of Statement is not proved.", 
        CbcmodelPackage.Literals.ABSTRACT_STATEMENT__PROVEN, 
        DslValidator.NOT_PROVED);
    }
    if ((!closedPost)) {
      this.info("PostCondition of Statement is not proved.", 
        CbcmodelPackage.Literals.ABSTRACT_STATEMENT__PROVEN, 
        DslValidator.NOT_PROVED);
    }
    if ((!closedStd)) {
      this.info("Statement is not proved.", 
        CbcmodelPackage.Literals.ABSTRACT_STATEMENT__PROVEN, 
        DslValidator.NOT_PROVED);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void checkProveOfMethodStatement(final MethodStatement statement) {
    Resource _eResource = statement.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    Iterator<CbCFormula> _filter = Iterators.<CbCFormula>filter(_allContents, CbCFormula.class);
    CbCFormula formula = _filter.next();
    TraverseFormula traverser = new TraverseFormula();
    traverser.traverseFormula(formula, statement);
    int numberFile = traverser.foundFile;
    Resource _eResource_1 = statement.eResource();
    URI _uRI = _eResource_1.getURI();
    final boolean closedPre = ProveWithKey.checkFileIsProved(_uRI, numberFile);
    Resource _eResource_2 = statement.eResource();
    URI _uRI_1 = _eResource_2.getURI();
    final boolean closedPost = ProveWithKey.checkFileIsProved(_uRI_1, (numberFile + 1));
    if ((!closedPre)) {
      this.info("PreCondition of MethodStatement is not proved.", 
        CbcmodelPackage.Literals.ABSTRACT_STATEMENT__PROVEN, 
        DslValidator.NOT_PROVED);
    }
    if ((!closedPost)) {
      this.info("PostCondition of MethodStatement is not proved.", 
        CbcmodelPackage.Literals.ABSTRACT_STATEMENT__PROVEN, 
        DslValidator.NOT_PROVED);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void checkProveOfSkipStatement(final SkipStatement statement) {
    Resource _eResource = statement.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    Iterator<CbCFormula> _filter = Iterators.<CbCFormula>filter(_allContents, CbCFormula.class);
    CbCFormula formula = _filter.next();
    TraverseFormula traverser = new TraverseFormula();
    traverser.traverseFormula(formula, statement);
    int numberFile = traverser.foundFile;
    Resource _eResource_1 = statement.eResource();
    URI _uRI = _eResource_1.getURI();
    final boolean closed = ProveWithKey.checkFileIsProved(_uRI, numberFile);
    if ((!closed)) {
      this.info("SkipStatement is not proved.", 
        CbcmodelPackage.Literals.ABSTRACT_STATEMENT__PROVEN, 
        DslValidator.NOT_PROVED);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void checkProveOfRepetitionStatement(final SmallRepetitionStatement statement) {
    Resource _eResource = statement.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    Iterator<CbCFormula> _filter = Iterators.<CbCFormula>filter(_allContents, CbCFormula.class);
    CbCFormula formula = _filter.next();
    TraverseFormula traverser = new TraverseFormula();
    traverser.traverseFormula(formula, statement);
    int numberFile = traverser.foundFile;
    Resource _eResource_1 = statement.eResource();
    URI _uRI = _eResource_1.getURI();
    boolean closedPre = ProveWithKey.checkFileIsProved(_uRI, numberFile);
    Resource _eResource_2 = statement.eResource();
    URI _uRI_1 = _eResource_2.getURI();
    boolean closedPost = ProveWithKey.checkFileIsProved(_uRI_1, (numberFile + 1));
    Resource _eResource_3 = statement.eResource();
    URI _uRI_2 = _eResource_3.getURI();
    boolean closedVariant = ProveWithKey.checkFileIsProved(_uRI_2, (numberFile + 2));
    if ((!closedPre)) {
      this.info("PreCondition of RepetitionStatement is not proved.", 
        CbcmodelPackage.Literals.SMALL_REPETITION_STATEMENT__PRE_PROVEN, 
        DslValidator.NOT_PROVED);
    }
    if ((!closedPost)) {
      this.info("PostCondition of RepetitionStatement is not proved.", 
        CbcmodelPackage.Literals.SMALL_REPETITION_STATEMENT__POST_PROVEN, 
        DslValidator.NOT_PROVED);
    }
    if ((!closedVariant)) {
      this.info("Variant of RepetitionStatement is not proved.", 
        CbcmodelPackage.Literals.SMALL_REPETITION_STATEMENT__VARIANT_PROVEN, 
        DslValidator.NOT_PROVED);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void checkProveOfSelectionStatement(final SelectionStatement statement) {
    Resource _eResource = statement.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    Iterator<CbCFormula> _filter = Iterators.<CbCFormula>filter(_allContents, CbCFormula.class);
    CbCFormula formula = _filter.next();
    TraverseFormula traverser = new TraverseFormula();
    traverser.traverseFormula(formula, statement);
    int numberFile = traverser.foundFile;
    Resource _eResource_1 = statement.eResource();
    URI _uRI = _eResource_1.getURI();
    boolean closed = ProveWithKey.checkFileIsProved(_uRI, numberFile);
    if ((!closed)) {
      this.info("PreCondition of SelectionStatement is not proved.", 
        CbcmodelPackage.Literals.SELECTION_STATEMENT__PRE_PROVE, 
        DslValidator.NOT_PROVED);
    }
  }
  
  @Check
  public void checkSyntaxOfVariable(final JavaVariable variable) {
    if ((((((!Objects.equal(variable.getName(), null)) && (!variable.getName().isEmpty())) && (!Objects.equal(variable.getType(), null))) && (!variable.getType().isEmpty())) && (!Objects.equal(variable.getConfidentiality(), null)))) {
      String _type = variable.getType();
      boolean _matches = _type.matches("[a-zA-Z]\\w*(\\[\\])?");
      boolean _not = (!_matches);
      if (_not) {
        this.warning("Type must be set.", 
          CbcmodelPackage.Literals.JAVA_VARIABLE__TYPE, 
          DslValidator.INVALID_NAME);
      }
      Confidentiality _confidentiality = variable.getConfidentiality();
      String _name = _confidentiality.getName();
      String _lowerCase = _name.toLowerCase();
      boolean _matches_1 = _lowerCase.matches("(high|low)");
      boolean _not_1 = (!_matches_1);
      if (_not_1) {
        this.warning("TrustLevel must be high/low.", 
          CbcmodelPackage.Literals.JAVA_VARIABLE__CONFIDENTIALITY, 
          DslValidator.INVALID_NAME);
      }
    }
  }
}
